{"version":3,"sources":["components/Report/Report.js","API.js","components/Search/Search.js","components/Gif/Gif.js","components/Gifs/Gifs.js","components/Pagination/Pagination.js","components/App/App.js","index.js"],"names":["ResultsGrid","useContext","StateCtx","searches","position","error","searchTerm","term","className","offset","pagination","total_count","runSearch","key","limit","callback","a","async","fetch","response","ok","json","result","type","payload","Search","apiKey","dispatch","useState","setSearchTerm","onSubmit","e","search","preventDefault","value","onChange","target","Gif","data","title","images","bitlyUrl","bitly_url","href","src","fixed_height","url","alt","Gifs","map","gif","id","Pagination","currentOffset","length","total","totalPages","Math","ceil","currentPage","goToPrevious","goToNext","goToPage","page","arr","totalAfter","showBefore","maxPerSide","showAfter","push","onClick","i","buildPagination","createContext","App","useReducer","state","Provider","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.66663079.chunk.js","sourcesContent":["import React, { useContext } from 'react';\r\nimport { StateCtx } from '../App/App';\r\nimport './Report.css';\r\n\r\nconst ResultsGrid = () => {\r\n  const [{ searches, position, error }] = useContext(StateCtx);\r\n  const searchTerm = searches[position.term];\r\n\r\n  if (!searchTerm && !error) {\r\n    return null;\r\n  }\r\n\r\n  const handleResponse = () => {\r\n    if (error) {\r\n      return 'An error occured. Please try again!';\r\n    }\r\n    if (searchTerm[position.offset] && searchTerm[position.offset].pagination.total_count === 0) {\r\n      return 'No results found!';\r\n    }\r\n    return (\r\n      searchTerm[position.offset]\r\n      && `found ${searchTerm[position.offset].pagination.total_count} results`\r\n    );\r\n  };\r\n\r\n  return <div className=\"report\">{ handleResponse() }</div>;\r\n};\r\n\r\nexport default ResultsGrid;\r\n","const runSearch = async (key, limit, term, callback, offset = 0) => {\r\n  try {\r\n    const response = await fetch(`http://api.giphy.com/v1/gifs/search?q=${term}&api_key=${key}&limit=${limit}&offset=${offset}`);\r\n    if (response.ok) {\r\n      const result = await response.json();\r\n      callback({ type: 'ADD_SEARCH', payload: { term, offset, result } });\r\n      callback({ type: 'UPDATE_ERROR', payload: false });\r\n    }\r\n  } catch {\r\n    callback({ type: 'UPDATE_ERROR', payload: true });\r\n  }\r\n};\r\n\r\nexport default runSearch;\r\n","import React, { useState, useContext } from 'react';\r\nimport { StateCtx } from '../App/App';\r\nimport Report from '../Report/Report';\r\nimport search from '../../API';\r\nimport './Search.css';\r\n\r\nconst Search = () => {\r\n  const [{ apiKey, limit, searches }, dispatch] = useContext(StateCtx);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n\r\n  const handleChange = e => {\r\n    setSearchTerm(e.target.value);\r\n  };\r\n\r\n  const handleSubmit = e => {\r\n    dispatch({ type: 'UPDATE_POSITION', payload: { term: searchTerm, offset: 0 } });\r\n\r\n    /* If the data isn't cached yet, do an API call. Otherwise, dispatching that action\r\n     above will tell the Gifs component to use the cached data. */\r\n    if (!searches[searchTerm]) {\r\n      search(apiKey, limit, searchTerm, dispatch);\r\n    }\r\n\r\n    e.preventDefault();\r\n  };\r\n\r\n  return (\r\n    <div className=\"search\">\r\n      <form onSubmit={handleSubmit}>\r\n        <input type=\"text\" value={searchTerm} onChange={handleChange} />\r\n        <input type=\"submit\" value=\"Giphy Search\" />\r\n      </form>\r\n      <Report />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Search;\r\n","import React from 'react';\r\nimport './Gif.css';\r\n\r\nconst Gif = ({ data }) => {\r\n  const { title, images, bitly_url: bitlyUrl } = data;\r\n\r\n  return (\r\n    <div className=\"gif\">\r\n      <a href={bitlyUrl}>\r\n        <img src={images.fixed_height.url} alt={title} />\r\n      </a>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Gif;\r\n","import React, { useContext } from 'react';\r\nimport { StateCtx } from '../App/App';\r\nimport Gif from '../Gif/Gif';\r\nimport './Gifs.css';\r\n\r\nconst Gifs = () => {\r\n  const [{ searches, position }] = useContext(StateCtx);\r\n  const { term, offset } = position;\r\n\r\n  /* Not going to render in the store doesn't have the data for a particular\r\n   search term (or a given offset of that search term) already cached. This\r\n   means the API call either wasn't made or wasn't successful. */\r\n\r\n  if (!searches[term] || !searches[term][offset]) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div className=\"gifs\">\r\n      { searches[term][offset].data.map(gif => <Gif key={gif.id} data={gif} />) }\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Gifs;\r\n","import React, { useContext } from 'react';\r\nimport { StateCtx } from '../App/App';\r\nimport search from '../../API';\r\nimport './Pagination.css';\r\n\r\nconst Pagination = () => {\r\n  const [{ apiKey, limit, searches, position }, dispatch] = useContext(StateCtx);\r\n  const { term, offset: currentOffset } = position;\r\n\r\n  const searchTerm = searches[term];\r\n\r\n  /* Only display pagination if the search data exists and has at least one page. */\r\n  if (!searchTerm || !searchTerm[currentOffset] || searchTerm[currentOffset].data.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const { total_count: total, offset } = searchTerm[currentOffset].pagination;\r\n\r\n  const totalPages = Math.ceil(total / limit);\r\n  const currentPage = offset / limit + 1;\r\n\r\n  /* This is the messiest bit of the entire app, and something I'm least proud of.\r\n      I wanted the sort of pagination, which follows the following rules:\r\n      1. Displays 'Previous' and 'Next' links only if there pages actually exist.\r\n      2. Displays links to 5 pages before the current one and 5 after, 11 in total.\r\n      3. If less than 5 pages exist, displays whatever is available and then\r\n          compensate on the other side, so for example 3 and 7, or 8 and 2.\r\n      4. If there are less than 11 pages in total, display whatever is available.\r\n      5. The current page is not clickable and is shown as visually distinctive.\r\n     The result satisfies these criteria, and should be performant. There is most\r\n     likely a better way to do this, however. */\r\n\r\n  const buildPagination = () => {\r\n    const arr = [];\r\n    const maxPerSide = 5;\r\n    const totalBefore = currentPage;\r\n    const totalAfter = totalPages - currentPage;\r\n    const showBefore = (() => {\r\n      if (totalBefore <= maxPerSide + 1) {\r\n        return totalBefore;\r\n      }\r\n\r\n      if (totalAfter >= maxPerSide) {\r\n        return maxPerSide + 1;\r\n      }\r\n\r\n      if (totalAfter < maxPerSide && maxPerSide * 2 - totalAfter < totalBefore) {\r\n        return maxPerSide * 2 - totalAfter + 1;\r\n      }\r\n\r\n      return maxPerSide;\r\n    })();\r\n    const showAfter = (() => totalAfter <= maxPerSide\r\n      ? totalAfter\r\n      : maxPerSide * 2 + 1 - showBefore\r\n    )();\r\n\r\n    currentPage !== 1 && arr.push(<button type=\"button\" key=\"previous\" onClick={goToPrevious}>Previous</button>);\r\n\r\n    for (let i = currentPage - showBefore; i < currentPage - 1; i++) {\r\n      arr.push(\r\n        <button type=\"button\" key={i + 1} onClick={() => goToPage(i)}>\r\n          {i + 1}\r\n        </button>,\r\n      );\r\n    }\r\n\r\n    arr.push(\r\n      <span key={currentPage} className=\"current\">\r\n        {currentPage}\r\n      </span>,\r\n    );\r\n\r\n    for (let i = 0; i < showAfter; i++) {\r\n      arr.push(\r\n        <button type=\"button\" key={currentPage + 1 + i} onClick={() => goToPage(currentPage + i)}>\r\n          {currentPage + 1 + i}\r\n        </button>,\r\n      );\r\n    }\r\n\r\n    currentPage !== totalPages && arr.push(<button type=\"button\" key=\"next\" onClick={goToNext}>Next</button>);\r\n    return arr;\r\n  };\r\n\r\n  const goToPrevious = () => {\r\n    dispatch({ type: 'UPDATE_POSITION', payload: { term, offset: offset - limit } });\r\n    if (!searchTerm[offset - limit]) {\r\n      search(apiKey, limit, term, dispatch, offset - limit);\r\n    }\r\n  };\r\n\r\n  const goToNext = () => {\r\n    dispatch({ type: 'UPDATE_POSITION', payload: { term, offset: offset + limit } });\r\n    if (!searchTerm[offset + limit]) {\r\n      search(apiKey, limit, term, dispatch, offset + limit);\r\n    }\r\n  };\r\n\r\n  const goToPage = page => {\r\n    dispatch({ type: 'UPDATE_POSITION', payload: { term, offset: page * limit } });\r\n    if (!searchTerm[page * limit]) {\r\n      search(apiKey, limit, term, dispatch, page * limit);\r\n    }\r\n  };\r\n\r\n  return <div className=\"pagination\">{ buildPagination() }</div>;\r\n};\r\n\r\nexport default Pagination;\r\n","import React, { useReducer, createContext } from 'react';\r\nimport Search from '../Search/Search';\r\nimport Gifs from '../Gifs/Gifs';\r\nimport Pagination from '../Pagination/Pagination';\r\n\r\nexport const StateCtx = createContext([null, () => {}]);\r\n\r\nconst App = () => {\r\n  const reducer = (state, { type, payload }) => {\r\n    switch (type) {\r\n      case 'UPDATE_ERROR':\r\n        return { ...state, error: payload };\r\n      case 'UPDATE_POSITION':\r\n        return {\r\n          ...state,\r\n          position: {\r\n            term: payload.term,\r\n            offset: payload.offset,\r\n          },\r\n        };\r\n      case 'ADD_SEARCH':\r\n        return {\r\n          ...state,\r\n          searches: {\r\n            ...state.searches,\r\n            [payload.term]: {\r\n              ...state.searches[payload.term],\r\n              [payload.offset]: payload.result,\r\n            },\r\n          },\r\n        };\r\n      default:\r\n        return state;\r\n    }\r\n  };\r\n\r\n  /* Sunce the API is using GET for the search endpoint, it's not\r\n   really possible to hide the key anyway, so it may as well sit here */\r\n\r\n  const initialState = {\r\n    searches: {},\r\n    error: false,\r\n    position: { term: null, offset: 0 },\r\n    apiKey: 'brXMsD0cTFgrd7yQh6u17ilSMIhDz2t9',\r\n    limit: 8,\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n\r\n  return (\r\n    <StateCtx.Provider value={[state, dispatch]}>\r\n      <Search />\r\n      <Gifs />\r\n      <Pagination />\r\n    </StateCtx.Provider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './components/App/App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}